---
title: Cmode
date: 2023-09-18 22:55:23 +09:00
categories: [Study, Crypto]
tags: [symmetric, key]     # TAG names should always be lowercase
math: true
mermaid: true
---

> By using your implementation of simple DES (that has 12 bit input to 12 bit output) in HW3, 
implement the CBC mode of operation using Python. You should submit cmode.pdf and 
cmode.py file in which cmode.pdf contains the souce code and the running results of 
implemented ciphers, and the cmode.py is the souce code of your implementation.
- cbc_genkey(): It outputs a key bit_list (size is 9) of random values.
- cbc_encrypt(keybits, ivbits, plainbits): It takes the key bit_list (size is 9), iv bit_list (size is 12), 
and a plaintext bit_list (size is multiple of 12), and then it outputs a ciphertext bit_list
- cbc_decrypt(keybits, ivbits, cipherbits): It takes the key bit_list, iv bit_list, and a ciphertext bit_list, 
and then it outputs a plaintext bit_list.


## 1. cbc_genkey()
- ëœë¤ ê°’ì˜ key_bit_list(9bit) ì¶œë ¥
- Simple Desë¥¼ CBC modeë¡œ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ì„œëŠ” 9bitì˜ randomí•œ keyê°€ í•„ìš”í•¨
```python
def cbc_genkey():
	key = []
    for i in range(9):
    	tmp = random.randint(0,1)
        key.append(tmp)
    return key
```
cbc_genkey()í•¨ìˆ˜ì—ì„œëŠ” 1ê³¼ 0ì¤‘ì—ì„œ ëœë¤í•˜ê²Œ 9ë²ˆ ì¶”ì¶œí•˜ì—¬ listë¥¼ êµ¬ì„±í•˜ì˜€ë‹¤. random.randint()í•¨ìˆ˜ëŠ” ì£¼ì–´ì§„ ë²”ìœ„ì•ˆì— ìˆëŠ” ì •ìˆ˜ë¥¼ ëœë¤í•˜ê²Œ ì¶”ì¶œí•˜ëŠ” ê²ƒì´ê¸°ì— í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì˜€ë‹¤.

![](/assets/img/_POST/Cmode/image1.png)

## 2. cbc_encrypt(keybits, ivbits, plainbits)
- key_bit_listì™€ ivbit, plainbitsë¥¼ ì…ë ¥ë°›ì•„ ì•”í˜¸ë¬¸ ì¶œë ¥
- keybits(9bit), ivbit(9bit), plainbits(12bit)
-  ğ¶0 = E(IV XOR ğ‘ƒ0, K), ğ¶1 = E(ğ¶0 XOR ğ‘ƒ1, K), ğ¶2 = E(ğ¶1 XOR ğ‘ƒ2, K)

Simple Desë¥¼ CBC modeë¡œ ìˆ˜í–‰í•œë‹¤ëŠ” ê²ƒì€ 12ì˜ ë°°ìˆ˜ í¬ê¸°ì˜ plaintextë¥¼ 12 bitë§Œí¼ì”© blockë‹¨ìœ„ë¡œ ë‚˜ëˆ„ì–´ Cipher Block Chaining ë°©ì‹ìœ¼ë¡œ ì•”í˜¸í™”ë¥¼ ì§„í–‰í•˜ëŠ” ê²ƒì´ë‹¤.<br> 
Cipher Block Chainingì€ ì•„ë˜ì˜ ê·¸ë¦¼ê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì§„í–‰ëœë‹¤. DESì•”í˜¸í™”ë¥¼ ì§„í–‰í•˜ê¸° ì „, Plaintextì™€ ì œê³µëœ IVë¥¼ XORì—°ì‚°ì„ í•œë‹¤. ì´í›„ì—ëŠ” IVëŒ€ì‹ ì— ì²«ë²ˆì§¸ ë¸”ë¡ì˜ ì•”í˜¸í™” ê°’ì„ ì‚¬ìš©í•˜ì—¬ DESì•”í˜¸í™” ì „, plaintextì™€ XORì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.
![](/assets/img/_POST/Cmode/image2.png)
```python
def cbc_encrypt(keybits, ivbits, plainbits):
    pblock_tmp = []  # ë¸”ë¡ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„ì‹œ ì €ì¥ì†Œ
    cipherbits = []  # ì•”í˜¸í™”ëœ ë¸”ë¡ì„ ì €ì¥í•  ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
    cnt = 0  # ë¸”ë¡ ë°˜ë³µì„ ìœ„í•œ ì¹´ìš´í„°
    IV_tmp = ivbits  # IVë¥¼ ì„ì‹œ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    
    while True:
        # í‰ë¬¸ì—ì„œ 12ë¹„íŠ¸ì”© ì¶”ì¶œ
        pblock_tmp = plainbits[cnt*12:(cnt+1)*12]
        
        # ì „ì²´ í‰ë¬¸ ë¸”ë¡ ì²˜ë¦¬ ì—¬ë¶€ í™•ì¸
        if(len(plainbits)/12 == cnt):
            break  # ëª¨ë“  ë¸”ë¡ì„ ì²˜ë¦¬í–ˆë‹¤ë©´ ë°˜ë³µë¬¸ ì¢…ë£Œ
        else:
            # í‰ë¬¸ ë¸”ë¡ì„ í˜„ì¬ IVì™€ XOR ì—°ì‚° ìˆ˜í–‰
            pblock_tmp = IV_xor(pblock_tmp, IV_tmp)
            
            # XORëœ ë¸”ë¡ì„ S-DES ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì•”í˜¸í™”
            pblock_tmp = sdes_encrypt(keybits, pblock_tmp)
            
            # ë‹¤ìŒ ë°˜ë³µì„ ìœ„í•´ IVë¥¼ ì•”í˜¸í™”ëœ ë¸”ë¡ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            IV_tmp = pblock_tmp
            
            # ë¸”ë¡ ì¹´ìš´í„° ì¦ê°€
            cnt += 1
            
            # ì²˜ë¦¬ëœ ë¸”ë¡ì„ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
            cipherbits.extend(pblock_tmp)
    
    # ì•”í˜¸í™”ëœ ë¸”ë¡ì„ ë‹´ì€ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    return cipherbits
```
cbc_encrypt()ëŠ” CBC modeë¡œ DESì•”í˜¸í™”ë¥¼ ì§„í–‰í•˜ëŠ” í•¨ìˆ˜ì´ê³  ì¸ìë¡œ keybits, ivbits, plainbitsë¥¼ ë°›ëŠ”ë‹¤. ì´ë•Œ, plainbitsëŠ” 12bitì˜ ë°°ìˆ˜ì˜ ê¸¸ì´ë¡œ ë°›ê³  keybitsëŠ” 9bitë¡œ ivbitsëŠ” 12bitë¡œ ë°›ëŠ”ë‹¤. <br>
pblock_tmp ë³€ìˆ˜ëŠ” ë¸”ë¡ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„ì‹œ ì €ì¥ì†Œì´ê³  cipherbitsëŠ” ì•”í˜¸í™”ëœ ë¸”ë¡ì„ ì €ì¥í•  ë³€ìˆ˜ì´ë‹¤. cnt ë³€ìˆ˜ëŠ” 12ë°°ìˆ˜ì˜ ê¸¸ì´ì¸ plainbitsë¥¼ ëª¨ë‘ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ì¹´ìš´í„° ë³€ìˆ˜ì´ê³  IV_tmpëŠ” ivbitsë¥¼ ì„ì‹œë¡œ ì €ì¥í•˜ëŠ” ë³€ìˆ˜ì´ë‹¤.<br>
while True ë°˜ë³µë¬¸ì„ í†µí•´ plainbitsì˜ ëª¨ë“  ë¸”ë¡ì´ ì•”í˜¸í™”ë  ìˆ˜ ìˆë„ë¡ í•œë‹¤. plainbits[cnt\*12:(cnt+1)\*12] ëŠ” í‰ë¬¸ì¸ plainbitsì—ì„œ 12bitë¥¼ ì¶”ì¶œí•œë‹¤. ì´í›„ ì „ì²´ í‰ë¬¸ ë¸”ë¡ì„ ì²˜ë¦¬í–ˆëŠ”ì§€ ifë¬¸ì„ í†µí•´ í™•ì¸í•˜ê³  ì²˜ë¦¬ë˜ì§€ ì•Šì•˜ìœ¼ë©´ elseë¬¸ìœ¼ë¡œ ë“¤ì–´ê°„ë‹¤. í‰ë¬¸ ë¸”ë¡ì„ í˜„ì¬ì˜ ivbitsì™€ xorì—°ì‚°ì„ ìˆ˜í–‰ì‹œí‚¨ë‹¤. ì´í›„ xorëœ ë¸”ë¡ì„ Simple DES ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ ì•”í˜¸í™”í•œë‹¤. [Simple DES](https://wjdgus06.github.io/posts/Simple Des/ "Simple DES í˜ì´ì§€ë¡œ ì´ë™") ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ì€ ì´ì „ í¬ìŠ¤íŒ…ì—ì„œ í™•ì¸ê°€ëŠ¥í•˜ë‹¤. ë‹¤ìŒ ë°˜ë³µì„ ìœ„í•´ ivbitsë¥¼ í˜„ì¬ ì•”í˜¸í™”ëœ ë¸”ë¡ìœ¼ë¡œ ì—…ë°ì´íŠ¸ í•´ì¤€ë‹¤. ì´ë ‡ê²Œ ì•”í˜¸í™”ëœ ë¸”ë¡ì€ ì•”í˜¸í™”ëœ ë¸”ë¡ì„ ì €ì¥í•˜ëŠ” cipherbitsì— ì €ì¥í•œë‹¤. ì•”í˜¸í™”ê°€ ì¢…ë£Œë˜ë©´ ì•”í˜¸í™” listê°€ ë‹´ê¸´ cipherbitsë¥¼ ë°˜í™˜í•œë‹¤.

![](/assets/img/_POST/Cmode/image3.png)



## 3.cbc_decrypt(keybits, ivbits, cipherbits)
- key_bit_listì™€ ivbit, cipehrbitsë¥¼ ì…ë ¥ë°›ì•„ ë³µí˜¸ë¬¸ ì¶œë ¥
-  ğ‘ƒ0 = IV XOR D(ğ¶0, K), ğ‘ƒ1 = ğ¶0 XOR D(ğ¶1, K), ğ‘ƒ2 = ğ¶1 XOR D(ğ¶2, K)<br>

2ë²ˆì—ì„œ simple Desë¥¼ CBC modeë¡œ ì•”í˜¸í™”í•œ ê²ƒì„ ë‹¤ì‹œ ë³µí˜¸í™”í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤. CBC modeì—ì„œ ë³µí˜¸í™”ëŠ” ì•„ë˜ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì§„í–‰ëœë‹¤. ì¦‰, ì•”í˜¸í™”ëœ ë¸”ë¡ê³¼ keyë¥¼ ì´ìš©í•˜ì—¬ ë¨¼ì € simple Desì˜ Decryptë¥¼ ê³„ì‚°í•œ í›„ IVê°’ê³¼ XORì—°ì‚°ì„ ì§„í–‰í•œë‹¤.
```python
def cbc_decrypt(keybits, ivbits, cipherbits):
    cipher_tmp = []  # ë¸”ë¡ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„ì‹œ ì €ì¥ì†Œ
    plainbits = []  # ë³µí˜¸í™”ëœ ë¸”ë¡ì„ ì €ì¥í•  ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
    cnt = 0  # ë¸”ë¡ ë°˜ë³µì„ ìœ„í•œ ì¹´ìš´í„°
    IV_tmp = []  # IVë¥¼ ì„ì‹œ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    
    while True:
        # 12ë¹„íŠ¸ì”© ì¶”ì¶œ
        cipher_tmp = cipherbits[cnt*12:(cnt+1)*12]
        
        # ì „ì²´ ë¸”ë¡ ì²˜ë¦¬ ì—¬ë¶€ í™•ì¸
        if(len(cipherbits)/12 == cnt):
            break  # ëª¨ë“  ë¸”ë¡ì„ ì²˜ë¦¬í–ˆë‹¤ë©´ ë°˜ë³µë¬¸ ì¢…ë£Œ
        else:
            # XORëœ ë¸”ë¡ì„ S-DES ë³µí˜¸í™” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë³µí˜¸í™”
            cipher_tmp = sdes_decrypt(keybits, cipher_tmp)

            if(cnt == 0):
                cipher_tmp = IV_xor(cipher_tmp,ivbits)
            else:
                cipher_tmp = IV_xor(cipher_tmp, IV_tmp)
            
            IV_tmp = cipherbits[cnt*12:(cnt+1)*12]
            # ë‹¤ìŒ ë°˜ë³µì„ ìœ„í•´ IV_tmp ì—…ë°ì´íŠ¸
            cnt += 1  # ë¸”ë¡ ì¹´ìš´í„° ì¦ê°€
            
            
            # ì²˜ë¦¬ëœ ë¸”ë¡ì„ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
            plainbits.extend(cipher_tmp)
    
    # ë³µí˜¸í™”ëœ ë¸”ë¡ì„ ë‹´ì€ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    return plainbits
```
cbc_decrypt()ëŠ” CBC modeë¡œ DESë³µí˜¸í™”ë¥¼ ì§„í–‰í•˜ëŠ” í•¨ìˆ˜ì´ê³  ì¸ìë¡œ keybits, ivbits,cipherbitsë¥¼ ë°›ëŠ”ë‹¤. ì´ë•Œ, cipherbitsëŠ” 12bitì˜ ë°°ìˆ˜ì˜ ê¸¸ì´ë¡œ ë°›ê³  keybitsëŠ” 9bitë¡œ ivbitsëŠ” 12bitë¡œ ë°›ëŠ”ë‹¤. <br>
cipher_tmp ë³€ìˆ˜ëŠ” ë¸”ë¡ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„ì‹œ ì €ì¥ì†Œì´ê³  plainbitsëŠ” ë³µí˜¸í™”ëœ ë¸”ë¡ì„ ì €ì¥í•  ë³€ìˆ˜ì´ë‹¤. cnt ë³€ìˆ˜ëŠ” 12ë°°ìˆ˜ì˜ ê¸¸ì´ì¸ cipherbitsë¥¼ ëª¨ë‘ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ì¹´ìš´í„° ë³€ìˆ˜ì´ê³  IV_tmpëŠ” ivbitsë¥¼ ì„ì‹œë¡œ ì €ì¥í•˜ëŠ” ë³€ìˆ˜ì´ë‹¤.<br>
while True ë°˜ë³µë¬¸ì„ í†µí•´ cipherbitsì˜ ëª¨ë“  ë¸”ë¡ì´ ë³µí˜¸í™”ë  ìˆ˜ ìˆë„ë¡ í•œë‹¤. cipherbits[cnt*12:(cnt+1)*12]ëŠ” ì•”í˜¸ë¬¸ì¸ cipherbitsì—ì„œ 12bitë¥¼ ì¶”ì¶œí•œë‹¤.<br>
ì „ì²´ ì•”í˜¸ë¬¸ ë¸”ë¡ì„ ì²˜ë¦¬í–ˆëŠ”ì§€ ifë¬¸ì„ í†µí•´ í™•ì¸í•˜ê³  ì²˜ë¦¬ë˜ì§€ ì•Šì•˜ìœ¼ë©´ elseë¬¸ìœ¼ë¡œ ë“¤ì–´ê°„ë‹¤. Ivbitsì™€ xorì—°ì‚°ì„ í•˜ê¸° ì „, Simple Desì˜ ë³µí˜¸í™” ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•˜ì—¬ ë³µí˜¸í™”ë¥¼ í•œë‹¤. ì´ë•Œ, [Simple DES](https://wjdgus06.github.io/posts/Simple Des/ "Simple DES í˜ì´ì§€ë¡œ ì´ë™") ë³µí˜¸í™” ì•Œê³ ë¦¬ì¦˜ì€ ì´ì „ í¬ìŠ¤íŒ…ì—ì„œ í™•ì¸ê°€ëŠ¥í•˜ë‹¤. ì´í›„ ivbitsì™€ xorì—°ì‚°ì„ ì§„í–‰í•´ì•¼ í•˜ëŠ”ë°, ì´ë•Œ cntê°€ 0ìœ¼ë¡œ ì²«ë²ˆì§¸ ë¸”ë¡ì„ ë³µí˜¸í™”í•˜ê³  ìˆë‹¤ë©´ í•¨ìˆ˜ì˜ ì¸ìë¡œ ë°›ì•˜ë˜ ivbitsë¥¼ ì‚¬ìš©í•˜ê³  ì´í›„ ë¸”ë¡ì—ì„œëŠ” IV_tmpì— ì €ì¥ëœ ivbitsë¥¼ ì‚¬ìš©í•˜ì—¬ xorì—°ì‚°ì„ í•œë‹¤. ì´ëŠ” ì´ì „ blockì˜ ì•”í˜¸ë¬¸ì„ ë‹¤ìŒ ì•”í˜¸ë¬¸ì„ ë³µí˜¸í™”í•  ë•Œ ivbitsë¡œì„œ ì‚¬ìš©í•œë‹¤ëŠ” ì  ë•Œë¬¸ì— ë‹¤ìŒê³¼ ê°™ì´ êµ¬ë¶„í•˜ì—¬ ì½”ë“œë¥¼ ì‘ì„±í•˜ì˜€ë‹¤.<br>
Xorì—°ì‚° ì´í›„, ë‹¤ìŒ ë¸”ë¡ì˜ ë³µí˜¸í™”ë¥¼ ìœ„í•´ IV_tmpë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  ë³µí˜¸í™”ëœ ë¸”ë¡ì„ plainbitë³€ìˆ˜ì— ì €ì¥í•œë‹¤. ë°˜ë³µë¬¸ì´ ì¢…ë£Œëœ í›„, ì¦‰ ëª¨ë“  ë¸”ë¡ì˜ ë³µí˜¸í™”ê°€ ì§„í–‰ëœ í›„ì— ë³µí˜¸í™”ëœ ë¸”ë¡ì„ ë‹´ì€ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•œë‹¤.
![](/assets/img/_POST/Cmode/image4.png)

## ì „ì²´ ì½”ë“œ
```python
# CBC
import random

def sdes_genkey():

    key = []
    for i in range(9):
        tmp = random.randint(0,1)
        key.append(tmp)
    return key

def round_key(key, num):
    if(num+8 > 9):
        add = num-1
        R_key = key[num:9]
        R_add = key[0:add]

        R_key = R_key + R_add
    else:
        R_key = key[num:num+8]
    
    return R_key

def expander(right):
    expand_R = []
    expand_R.append(right[0])
    expand_R.append(right[1])
    expand_R.append(right[3])
    expand_R.append(right[2])
    expand_R.append(right[3])
    expand_R.append(right[2])
    expand_R.append(right[4])
    expand_R.append(right[5])
    return expand_R
def S_box1(L_Right):
    Sbox1 = [['101', '010', '001', '110', '011', '100', '111', '000'],
            ['001', '100', '110', '010', '000', '111', '101', '011']]

    if(L_Right[0] == 0):
        k = 0
    else:
        k = 1

    binary = ""
    for i in range (1,4):
        binary += str(L_Right[i])

    return list(Sbox1[k][int(binary, 2)])
    
def S_box2(R_Right):

    Sbox2 = [['100', '000', '110', '101', '111', '001', '011', '010'],
            ['101', '011', '000', '111', '110', '010', '001', '100']]

    if(R_Right[0] == 0):
        k = 0 
    else:
        k = 1

    binary = ""
    for i in range (1,4):
        binary += str(R_Right[i])

    return list(Sbox2[k][int(binary, 2)])  
    
def sdes_encrypt(key, pblock):

    for i in range(3):
        Left = pblock[0:6] # Left ->  0~5 list item
        Right = pblock[6:12] # Right -> 6~11 list item

        Origin_Right = Right
        # function <- R
        
        Rkey = round_key(key, i) # make Round key

        Right = expander(Right) # Right Expand: 6bit -> 8bit

        
        for j in range(8):
            Right[j] = Rkey[j] ^ Right[j] # round_key XOR expander_Right

        # Rightë¥¼ 4bitì”© ë‚˜ëˆ„ê¸°
        L_Right = Right[0:4] # L_Right -> 0~3 list item
        R_Right = Right[4:8] # R_Right -> 4~7 list item

        L_Right = S_box1(L_Right) # S_box1
        R_Right = S_box2(R_Right) # S_box2

        Right = L_Right + R_Right

        # S_boxë¥¼ í†µí•´ return ë˜ëŠ” listëŠ” ë¬¸ìì—´ listì„
        # -> ì •ìˆ˜í˜• listë¡œ ë³€ê²½
        Right = list(map(int, Right))

        for j in range(6):
            Right[j] = Left[j] ^ Right[j]
            # Left 6bitì™€ Right 6bit XOR ì—°ì‚°
        pblock = Origin_Right + Right


    return pblock
        
        
def sdes_decrypt(key, cblock):
    
    cblock_inverse = cblock[6:]
    cblock_inverse.extend(cblock[:6])
    cblock = cblock_inverse

    for i in range(3):

        Left = cblock[0:6] # Left ->  0~5 list item
        Right = cblock[6:12] # Right -> 6~11 list item

        Origin_Right = Right
        # function <- R
        
        Rkey = round_key(key, 2-i) # make Round key

        Right = expander(Right) # Right Expand: 6bit -> 8bit
        
        for j in range(8):
            Right[j] = Rkey[j] ^ Right[j] # round_key XOR expander_Right

        # Rightë¥¼ 4bitì”© ë‚˜ëˆ„ê¸°
        L_Right = Right[0:4] # L_Right -> 0~3 list item
        R_Right = Right[4:8] # R_Right -> 4~7 list item

        L_Right = S_box1(L_Right) # S_box1
        R_Right = S_box2(R_Right) # S_box2

        Right = L_Right + R_Right

        # S_boxë¥¼ í†µí•´ return ë˜ëŠ” listëŠ” ë¬¸ìì—´ listì„
        # -> ì •ìˆ˜í˜• listë¡œ ë³€ê²½
        Right = list(map(int, Right))

        for j in range(6):
            Right[j] = Left[j] ^ Right[j]
            # Left 6bitì™€ Right 6bit XOR ì—°ì‚°
        cblock = Origin_Right + Right

    pblock_inverse = cblock[6:]
    pblock_inverse.extend(cblock[:6])
    pblock = pblock_inverse
    #ê²°ê³¼ê°€ Leftì™€ Rightê°€ ë°˜ëŒ€ë¡œ ë˜ì–´ ë‚˜ì˜¤ê¸° ë•Œë¬¸ì— ìˆ˜í–‰
    return pblock

def IV_xor(text, IV):
    for i in range (12):
        text[i] = text[i] ^ IV[i]
    return text
        
def cbc_genkey():
    key = []
    for i in range(9):
        tmp = random.randint(0,1)
        key.append(tmp)
    return key

def cbc_encrypt(keybits, ivbits, plainbits):
    pblock_tmp = []  # ë¸”ë¡ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„ì‹œ ì €ì¥ì†Œ
    cipherbits = []  # ì•”í˜¸í™”ëœ ë¸”ë¡ì„ ì €ì¥í•  ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
    cnt = 0  # ë¸”ë¡ ë°˜ë³µì„ ìœ„í•œ ì¹´ìš´í„°
    IV_tmp = ivbits  # IVë¥¼ ì„ì‹œ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    
    while True:
        # í‰ë¬¸ì—ì„œ 12ë¹„íŠ¸ì”© ì¶”ì¶œ
        pblock_tmp = plainbits[cnt*12:(cnt+1)*12]
        
        # ì „ì²´ í‰ë¬¸ ë¸”ë¡ ì²˜ë¦¬ ì—¬ë¶€ í™•ì¸
        if(len(plainbits)/12 == cnt):
            break  # ëª¨ë“  ë¸”ë¡ì„ ì²˜ë¦¬í–ˆë‹¤ë©´ ë°˜ë³µë¬¸ ì¢…ë£Œ
        else:
            # í‰ë¬¸ ë¸”ë¡ì„ í˜„ì¬ IVì™€ XOR ì—°ì‚° ìˆ˜í–‰
            pblock_tmp = IV_xor(pblock_tmp, IV_tmp)
            
            # XORëœ ë¸”ë¡ì„ S-DES ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì•”í˜¸í™”
            pblock_tmp = sdes_encrypt(keybits, pblock_tmp)
            
            # ë‹¤ìŒ ë°˜ë³µì„ ìœ„í•´ IVë¥¼ ì•”í˜¸í™”ëœ ë¸”ë¡ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            IV_tmp = pblock_tmp
            
            # ë¸”ë¡ ì¹´ìš´í„° ì¦ê°€
            cnt += 1
            
            # ì²˜ë¦¬ëœ ë¸”ë¡ì„ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
            cipherbits.extend(pblock_tmp)
    
    # ì•”í˜¸í™”ëœ ë¸”ë¡ì„ ë‹´ì€ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    return cipherbits

def cbc_decrypt(keybits, ivbits, cipherbits):
    cipher_tmp = []  # ë¸”ë¡ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„ì‹œ ì €ì¥ì†Œ
    plainbits = []  # ë³µí˜¸í™”ëœ ë¸”ë¡ì„ ì €ì¥í•  ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
    cnt = 0  # ë¸”ë¡ ë°˜ë³µì„ ìœ„í•œ ì¹´ìš´í„°
    IV_tmp = []  # IVë¥¼ ì„ì‹œ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
    
    while True:
        # 12ë¹„íŠ¸ì”© ì¶”ì¶œ
        cipher_tmp = cipherbits[cnt*12:(cnt+1)*12]
        
        # ì „ì²´ ë¸”ë¡ ì²˜ë¦¬ ì—¬ë¶€ í™•ì¸
        if(len(cipherbits)/12 == cnt):
            break  # ëª¨ë“  ë¸”ë¡ì„ ì²˜ë¦¬í–ˆë‹¤ë©´ ë°˜ë³µë¬¸ ì¢…ë£Œ
        else:
            # XORëœ ë¸”ë¡ì„ S-DES ë³µí˜¸í™” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë³µí˜¸í™”
            cipher_tmp = sdes_decrypt(keybits, cipher_tmp)

            if(cnt == 0):
                cipher_tmp = IV_xor(cipher_tmp,ivbits)
            else:
                cipher_tmp = IV_xor(cipher_tmp, IV_tmp)
            
            IV_tmp = cipherbits[cnt*12:(cnt+1)*12]
            # ë‹¤ìŒ ë°˜ë³µì„ ìœ„í•´ IV_tmp ì—…ë°ì´íŠ¸
            cnt += 1  # ë¸”ë¡ ì¹´ìš´í„° ì¦ê°€
            
            
            # ì²˜ë¦¬ëœ ë¸”ë¡ì„ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
            plainbits.extend(cipher_tmp)
    
    # ë³µí˜¸í™”ëœ ë¸”ë¡ì„ ë‹´ì€ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    return plainbits

```
